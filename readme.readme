Тема 1: Автоматы и регулярные выражения
Определение направления
Конечные автоматы — абстрактные вычислительные модели для распознавания строк, соответствующих заданному шаблону (регулярному выражению). Используются в компиляторах, валидации форм, поиске и обработке текста.

Яркий алгоритм
Thompson’s Construction — преобразует регулярное выражение в недетерминированный конечный автомат (NFA).

Определение алгоритма
Thompson’s Construction рекурсивно строит NFA из регулярного выражения, используя правила для:

Базовых символов (a)
Конкатенации (ab)
Объединения (a|b)
Замыкания (a*)

Пошаговое объяснение
Каждому символу сопоставляется NFA из двух состояний.
Операторы (|, ., *) комбинируют подавтоматы через ε-переходы.
При распознавании:
Вычисляем ε-замыкание начального состояния.
Для каждого символа переходим по соответствующим рёбрам и снова вычисляем ε-замыкание.
Если в конце хотя бы одно состояние — accept → строка принимается.


Блок-схема 
НАЧАЛО
│
├─ Ввести регулярное выражение и строку
│
├─ Построить NFA с помощью Thompson’s Construction
│   └─ Рекурсивно обработать символы и операторы
│
├─ Вычислить ε-замыкание начального состояния
│
├─ Для каждого символа строки:
│   ├─ Перейти по соответствующим рёбрам
│   └─ Вычислить новое ε-замыкание
│
├─ Если множество состояний пусто → ОТКЛОНЕНО
│
└─ Если хоть одно состояние accept → ПРИНЯТО
КОНЕЦ

Временная сложность
Построение NFA: O(m), где m — длина регулярного выражения.
Распознавание строки длины n: O(n·m) в худшем случае.
Почему? Каждый символ строки может активировать до O(m) состояний (из-за ε-переходов), и вычисление ε-замыкания также O(m).

Тема 2: Алгоритмы во внешней памяти
Определение направления
Алгоритмы, работающие с данными, не помещающимися в RAM, минимизируя I/O-операции (чтение/запись блоков с диска). Ключевая модель: External Memory Model (N данных, M памяти, B — размер блока).

Яркий алгоритм
External Merge Sort — сортировка больших файлов через внешнюю память.

Определение алгоритма
External Merge Sort разбивает входной файл на чанки размером ≤ M, сортирует их в RAM, записывает временные файлы, затем сливает их по k = ⌊M/B⌋ за раз.

Пошаговое объяснение
Разбиение: вход делится на блоки по chunk_size.
Сортировка в RAM: каждый блок сортируется стандартным алгоритмом (например, Timsort в Python).
Запись во временные файлы.
Слияние: открываем все файлы, читаем по одной строке, строим min-heap, извлекаем минимумы, дозаписываем.
Удаляем временные файлы.

Блок-схема
НАЧАЛО
│
├─ Ввести данные
│
├─ Разбить на чанки размером ≤ M
│
├─ Для каждого чанка:
│   ├─ Отсортировать в памяти
│   └─ Записать во временный файл
│
├─ Открыть все временные файлы
│
├─ Инициализировать min-heap первыми значениями
│
├─ Пока heap не пуст:
│   ├─ Извлечь минимум → добавить в результат
│   └─ Загрузить следующее значение из того же файла в heap
│
└─ Вернуть результат
КОНЕЦ

 Временная (I/O) сложность

O(N/B * logm/b N/B)

Каждый уровень слияния читает/пишет все N/B блоков. Количество уровней — log_{M/B}(N/B), так как за один проход сливается до M/B файлов.

Тема 3: Вычислительная геометрия

Определение алгоритма
Graham Scan — алгоритм построения выпуклой оболочки конечного множества точек на плоскости. Выпуклая оболочка — минимальный выпуклый многоугольник, содержащий все точки.

Пошаговое объяснение работы
Найти стартовую точку — самую нижнюю (и левую при равенстве). Она гарантированно входит в оболочку.
Отсортировать все остальные точки по полярному углу относительно стартовой. При равных углах — по расстоянию (ближе первыми).
Инициализировать стек оболочки.
Для каждой точки в отсортированном списке:
Пока последние два ребра в стеке образуют невыпуклый поворот (правый или прямой), удаляем последнюю точку.
Добавляем текущую точку в стек.
Стек содержит точки оболочки в порядке против часовой стрелки.

Блок-схема
НАЧАЛО
│
├─ Ввод точек
│
├─ Найти стартовую точку P0 (мин y, затем мин x)
│
├─ Отсортировать остальные точки по углу относительно P0
│
├─ Инициализировать стек = [P0]
│
├─ Для каждой точки P в отсортированном списке:
│     │
│     └─ Пока в стеке ≥2 точек И поворот (предпоследняя → последняя → P) НЕ левый:
│           Удалить последнюю точку из стека
│     └─ Добавить P в стек
│
└─ Вывести стек как выпуклую оболочку
КОНЕЦ

Временная сложность (ещё раз с акцентом)
Сортировка: O(n log n) — доминирующий этап.
Построение стека: O(n) — каждая точка входит и выходит из стека не более 1 раза.
Итого: O(n log n)
Оптимальность: Невозможно построить выпуклую оболочку быстрее, чем за O(n log n) — задача эквивалентна сортировке (можно снизить к ней).

Тема 6: Алгоритмы потоков в сетях

Определение направления
Задача — найти максимальный поток от источника (source) к стоку (sink) в ориентированной сети с пропускными способностями рёбер. Применяется в логистике, matching, computer vision.

Яркий алгоритм
Алгоритм Эдмондса–Карпа — реализация Форда–Фалкерсона с BFS для поиска увеличивающих путей.

Определение алгоритма
На каждом шаге:

Ищется кратчайший (в рёбрах) увеличивающий путь от source к sink в остаточной сети с помощью BFS.
По пути пропускается максимально возможный поток.
Обновляется остаточная сеть.
Повторять, пока путь существует.

Пошаговое объяснение
Строим остаточную сеть (изначально — исходный граф).
Пока существует путь от source к sink в остаточной сети:
Находим кратчайший (BFS).
Определяем узкое место (мин. пропускная способность на пути).
Уменьшаем пропускные способности прямых рёбер, увеличиваем обратные.
Добавляем поток к итоговому значению.
Возвращаем суммарный поток.

 Блок-схема
НАЧАЛО
│
├─ Ввести граф, source, sink
│
├─ Инициализировать остаточную сеть
│
├─ Цикл:
│   ├─ BFS: найти путь от source к sink
│   ├─ Если путь не найден → ВЫХОД
│   ├─ Найти min_capacity на пути
│   ├─ Обновить остаточные рёбра (прямые – min_cap, обратные + min_cap)
│   └─ max_flow += min_cap
│
└─ Вывести max_flow
КОНЕЦ


 Временная сложность
Сложность: O(V·E²)
Почему?
BFS: O(E)
Количество итераций: O(V·E), так как каждый раз расстояние до стока не уменьшается, и каждое ребро может стать «критическим» не более O(V) раз.
Итого: O(E) × O(V·E) = O(V·E²)



