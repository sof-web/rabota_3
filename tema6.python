from collections import deque

def edmonds_karp(n, edges, source, sink):
    residual = [[0] * n for _ in range(n)]
    for u, v, cap in edges:
        residual[u][v] += cap

    def bfs():
        parent = [-1] * n
        visited = [False] * n
        queue = deque([source])
        visited[source] = True
        while queue:
            u = queue.popleft()
            for v in range(n):
                if not visited[v] and residual[u][v] > 0:
                    visited[v] = True
                    parent[v] = u
                    if v == sink:
                        return parent
                    queue.append(v)
        return None

    max_flow = 0
    while True:
        parent = bfs()
        if parent is None:
            break
        path_flow = float('inf')
        v = sink
        while v != source:
            u = parent[v]
            path_flow = min(path_flow, residual[u][v])
            v = u
        v = sink
        while v != source:
            u = parent[v]
            residual[u][v] -= path_flow
            residual[v][u] += path_flow
            v = u
        max_flow += path_flow
    return max_flow

n = int(input("Введите количество вершин: "))
m = int(input("Введите количество рёбер: "))
edges = []
print("Введите рёбра в формате: u v пропускная_способность (вершины от 0 до n-1)")
for _ in range(m):
    u, v, cap = map(int, input().split())
    edges.append((u, v, cap))

source = int(input("Источник: "))
sink = int(input("Сток: "))

flow = edmonds_karp(n, edges, source, sink)
print("Максимальный поток:", flow)
